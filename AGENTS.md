# 小说阅读播放器 agents 设计说明（agents.md）

## 一、项目概述

- **项目名称**：小说阅读播放器（CLI 版）
- **目标**：提供一个命令行下的小说阅读 + 语音播放工具，基于 `edge-tts` 将 TXT 小说文本转换为语音，并支持分段阅读、缓存与按键控制播放。
- **运行环境**：
  - Python ≥ 3.10
  - 操作系统：macOS / Linux（优先保证这两个），后续可考虑 Windows
  - 必要依赖：`edge-tts`、音频播放库（例如：`playsound` 或 `pydub` + `simpleaudio` 等）


## 二、运行方式与预期行为

### 1. 不带参数启动：设置模式

python main.py

行为：
  1.  启动“设置页面”（命令行交互界面即可；后续可扩展为 TUI）。
  2.  列出 edge-tts 的关键选项并允许用户配置：
  - voice（默认：zh-CN-YunxiNeural）
  - rate（默认：+20%）
  - 后续预留：volume、pitch 等（可以先不实现）
  3.  设置内容保存到本地配置文件（例如：config.json 或 settings.toml），供后续朗读使用。
  4.  设置完成后程序退出。

2. 带 TXT 参数启动：阅读 + 播放模式

python main.py 长夜难明.txt

行为：
  1.  读取并解析指定 TXT 文件。
  2.  使用 book.py 根据当前切分策略将文本切成若干“分段”。
  3.  进入主阅读界面：
  - 顶部显示 当前状态（如：当前章节、当前段索引 / 总段数、播放状态）。
  - 中部显示 当前分段的文本内容。
  - 底部显示 翻页导航提示 + 播放状态（暂停 / 播放中）。
  4.  监听键盘按键并实时处理：
  - ESC：退出程序。
  - 上 / 下：上一段 / 下一段。
  - 左 / 右：预留（例如：上一章 / 下一章 或 快速跳转）。
  - 空格：播放 / 暂停当前分段的语音。
  5.  与 player.py + cache.py 协同：
  - 对当前分段文本进行 TTS 缓存 / 播放。
  - 支持多段并行缓存下载（前后几段预下载），但播放时同一时刻只允许一个 mp3 播放。


## 三、整体模块划分

1. main.py —— 程序入口 & 主界面

职责：
  1.  解析命令行参数：
  - 无参数 → 进入“设置模式”。
  - 有 TXT 文件参数 → 进入“阅读 + 播放模式”。
  2.  设置模式：
  - 调用一个专门的 SettingsManager / 函数：
  - 获取 / 显示当前配置。
  - 提示用户输入新的 voice、rate 等。
  - 校验输入（例如 rate 必须是 +20% 这类格式）。
  - 将配置写入磁盘。
  3.  阅读模式：
  - 读取配置文件（voice、rate 等）。
  - 加载 TXT 文件内容。
  - 调用 book.py 进行分段切分。
  - 初始化播放器（player.py）和缓存管理器（cache.py）。
  - 维护当前“阅读上下文”：
  - 当前分段索引
  - 总分段数
  - 当前分段文本
  - 播放状态（准备中 / 播放中 / 暂停 / 已结束）
  - 绘制/刷新主界面（简单版本可以直接 print + 清屏）。
  - 捕获按键事件并做对应处理：
  - 移动分段索引、刷新界面。
  - 调用 player 播放 / 暂停。
  4.  统一异常处理和退出清理：
  - 捕获异常时，给出友好提示（例如：TXT 文件不存在、配置错误等）。
  - 停止播放、释放资源。


2. cache.py —— 缓存与下载管理

职责：
  1.  路径管理：
  - 文本文件路径。
  - 缓存根目录，例如：~/.novel_player_cache/。
  - mp3 子目录，例如：~/.novel_player_cache/mp3/。
  - 日志目录，例如：~/.novel_player_cache/logs/。
  2.  缓存命名规则：
  - 对“文本内容”或“文本内容 + voice + rate”计算 MD5，作为 mp3 文件名的前缀/全名，避免重复下载。
  - 示例：md5_hex[:16].mp3。
  3.  核心函数示意：
  - get_mp3_path(text: str, voice: str, rate: str) -> str：
  - 根据 text/voice/rate 计算 md5。
  - 生成 mp3 目标路径。
  - ensure_mp3(text: str, voice: str, rate: str) -> str：
  - 如果 mp3 已存在 → 直接返回路径。
  - 如果 mp3 不存在 → 提交下载任务到线程池，等待完成后返回路径。
  4.  多线程下载：
  - 使用 ThreadPoolExecutor 或类似工具。
  - 支持并行下载多个分段的 mp3（比如当前段 + 前后预读的几段）。
  - 控制最大并发数，避免网络/IO 过载。
  5.  日志记录：
  - 对每一次实际的下载事件记录日志（不含命中缓存的情况，或者单独计数）。
  - 日志字段：
  - 开始时间
  - 结束时间
  - 耗时（结束时间 - 开始时间）
  - 文本前 20 个字（用于排查问题）
  - 对应 mp3 路径
  - 建议日志格式：
  - 每行一个 JSON 或 CSV，便于后续分析。
  - 文件名可以按日期拆分，例如：tts_2025-12-01.log。


3. player.py —— 播放器

职责：
  1.  提供统一的“播放接口”，对上层隐藏具体音频库的差异。
  2.  输入参数：
  - text: str：文本内容。
  - play: bool：是否在下载完成后立即播放。
  3.  基本流程：
  1.  根据文本 + 当前配置（voice, rate）调用 cache.py：
  - 获取 mp3 路径（可能触发下载）。
  2.  当 play=True：
  - 确保只播放唯一一个 mp3：
  - 如果已有其他播放在进行，先停止之（或等待其结束，看设计）。
  - 调用底层音频库播放对应 mp3。
  4.  播放控制：
  - play_file(path: str)：播放指定 mp3 文件。
  - pause()：暂停当前播放（如底层库不支持暂停，则可改为“停止”）。
  - resume()：从暂停恢复，如不支持则视为重新播放。
  - stop()：停止播放。
  - 状态：
  - IDLE / PLAYING / PAUSED / STOPPED 等。

备注：
优先实现最小可用版本——即只支持“播放 / 停止”，暂停可在后续版本补充。界面逻辑对“停止”也可以表现为“暂停”，实现上稍宽松。


4. book.py —— 文本切割程序

职责：
  1.  负责将完整 TXT 文本切成一个个“分段”，并以结构化数据返回，例如：

class Segment(BaseModel):
    index: int
    title: str | None
    text: str

class Book(BaseModel):
    title: str | None
    segments: list[Segment]

  2.  切分策略 type（后续可扩展）：
  - type=简单：
  - 默认策略。
  - 逻辑：按“非空行”计数，每 10 行（不包括空行）合并为一个分段。
  - 剩余不足 10 行也作为一个分段。
  - type=章：
  - 识别“第XX章”、“第X回”、“Chapter XX”等模式，按章标题分割。
  - 本版本可以先留空接口或实现简单正则，后续逐步增强。
  - type=卷章：
  - 先按“卷”进行大分割，再在卷内按“章”细分。
  - type=卷回节：
  - 再往下细分到“节”级别。
  3.  首期实现要求：
  - 必须优先实现 type=简单，其他类型可以先设计函数签名，内部暂时抛出 NotImplementedError 或返回原始简单切分结果。
  4.  返回结构：
  - 必须保证 segments 是有序的。
  - 每个 segment 的 text 不包含两端多余空行。

## 四、配置管理与默认值
  1.  配置文件建议路径（按用户家目录）：
  - ~/.novel_player/config.json
  2.  默认配置内容：
```json
{
  "voice": "zh-CN-YunxiNeural",
  "rate": "+20%",
  "split_type": "简单",
  "preload_segments": 2
}
```

## 五、命令行界面与按键交互设计
  1.  主界面信息布局（文本模式）：
  - 第一行：状态栏
  - 示例：[长夜难明] 段 3 / 128 | 状态: 播放中 | voice: zh-CN-YunxiNeural | rate: +20%
  - 空一行。
  - 中间多行：当前分段正文。
  - 底部 2～3 行：帮助信息 / 按键提示
  - 示例：↑上一段  ↓下一段  空格: 播放/暂停  ESC: 退出
  2.  按键映射详细说明：
  - ESC：
  - 立刻停止播放（若有），退出程序。
  - ↑：
  - 如果当前不是第一段，则 index -= 1。
  - 刷新界面，自动停止当前播放（可选），不自动播放上一段，需用户按空格。
  - ↓：
  - 如果当前不是最后一段，则 index += 1。
  - 刷新界面，行为同上。
  - ← / →：
  - 暂时预留（可映射为“向前/向后跳 N 段”，先不实现也可以）。
  - 空格：
  - 如果当前状态为“未播放 / 停止”：调用 player.play(text, play=True)。
  - 如果当前状态为“播放中”：调用 player.pause() 或 stop()。
  - 如果当前状态为“暂停”：调用 player.resume() 或重新播放。
  3.  跨平台按键捕获：
  - 设计上需要一个独立的输入层，封装不同系统的按键读取。
  - 简化思路：优先保证在 macOS / Linux 下工作，使用 curses 或 tty + 非阻塞读取。
  - 后续再考虑 Windows 兼容。

## 六、日志与调试
  1.  日志分级：
  - INFO：正常下载、播放事件。
  - WARNING：缓存命中冲突、不一致情况。
  - ERROR：edge-tts 调用失败、音频播放失败、文件 IO 错误等。
  2.  日志位置：
  - 文本/下载耗时日志：~/.novel_player/logs/tts_YYYY-MM-DD.log
  - 程序运行日志（可选）：~/.novel_player/logs/app.log
  3.  辅助调试信息：
  - 每次按键事件可以在 DEBUG 模式下输出：“Key pressed: UP/DOWN/SPACE”等。
  - edge-tts 请求失败时记录完整错误信息，并提示用户检查网络 / 配置。

## 七、开发节奏建议（供 Codex / Agent 执行）

建议按以下顺序迭代实现，确保每一步都可运行、可测试。

  1.  Step 1：基础结构搭建
  - 创建 main.py / cache.py / player.py / book.py 四个文件。
  - 在 main.py 实现命令行参数解析和“Hello World”级别逻辑。
  2.  Step 2：实现配置管理与设置模式
  - 实现配置读写模块（可以直接写在 main.py 或 config.py）。
  - 当无参数启动时：
  - 显示当前配置。
  - 允许用户输入 voice / rate。
  - 保存配置到本地文件。
  3.  Step 3：实现 type=简单 文本切分
  - 在 book.py 中实现：
  - 加载 TXT 文件。
  - 去除空行，按每 10 行一段进行切分。
  - 提供 load_book(path, split_type="简单") -> Book 接口。
  4.  Step 4：实现缓存逻辑（不含线程池）
  - 在 cache.py 中实现：
  - 文本+配置 → md5 → mp3 路径。
  - 如果 mp3 不存在，调用 edge-tts 下载。
  - 在 player.py 中简单实现：
  - 接收 text，使用 cache.ensure_mp3 输出 mp3 路径。
  - 使用简单播放库同步播放。
  5.  Step 5：加入多线程下载
  - 在 cache.py 中加入 ThreadPoolExecutor：
  - 实现同步接口 ensure_mp3 + 异步预下载接口 preload_segments(...)。
  - 在主程序中对前后若干分段调用预下载。
  6.  Step 6：实现主阅读界面 + 按键控制
  - 在 main.py 中使用简单清屏 + 重绘方式展示界面。
  - 实现基础按键捕获和状态控制：
  - 切换分段。
  - 播放 / 停止。
  7.  Step 7：优化与扩展
  - 增加 type=章 的简单识别逻辑。
  - 优化界面体验（例如窗口大小适配、滚动显示长段落）。
  - 增强播放控制（真正的暂停 / 恢复）。

---

## 八、质量要求
  1.  代码风格：
  - 使用类型标注（type hints）。
  - 合理划分函数，避免超长函数。
  - 中文注释简明扼要，重点标注关键设计点。
  2.  错误处理：
  - 所有文件 IO、网络请求、音频播放都需要 try/except 包裹，给出明确错误信息。
  - 避免程序直接崩溃；尽可能提示用户问题所在。
  3.  可扩展性：
  - 分段策略、TTS 参数、播放库等都需要留出扩展空间。
  - 避免将 magic string 写死在多个地方（如 voice 名称、默认路径等）。